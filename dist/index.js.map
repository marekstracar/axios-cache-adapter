{"version":3,"names":[],"mappings":"","sources":["index.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('axios'), require('md5'), require('@tusbar/cache-control')) :\n    typeof define === 'function' && define.amd ? define('index', ['exports', 'axios', 'md5', '@tusbar/cache-control'], factory) :\n    (global = global || self, factory(global.index = {}, global.Axios, global.md5, global.cacheControl));\n}(this, (function (exports, Axios, md5, cacheControl) { 'use strict';\n\n    Axios = Axios && Object.prototype.hasOwnProperty.call(Axios, 'default') ? Axios['default'] : Axios;\n    md5 = md5 && Object.prototype.hasOwnProperty.call(md5, 'default') ? md5['default'] : md5;\n\n    async function limit (config) {\n        const length = await config.store.length();\n\n        if (length < config.limit) return;\n\n        config.debug(`Current store size: ${length}`);\n\n        let firstItem;\n\n        await config.store.iterate((value, key) => {\n            if (!firstItem) firstItem = { value, key };\n            if (value.expires < firstItem.value.expires) firstItem = { value, key };\n        });\n\n        if (firstItem) {\n            config.debug(`Removing item: ${firstItem.key}`);\n\n            await config.store.removeItem(firstItem.key);\n        }\n    }\n\n    // https://github.com/lodash/lodash/blob/master/isObject.js\n    function isObject (value) {\n        const type = typeof value;\n        return value != null && (type === 'object' || type === 'function');\n    }\n\n    // https://github.com/lodash/lodash/blob/master/.internal/getTag.js\n    function getTag (value) {\n        if (value === null) {\n            return value === undefined ? '[object Undefined]' : '[object Null]';\n        }\n        return Object.prototype.toString.call(value);\n    }\n\n    // https://github.com/lodash/lodash/blob/master/isFunction.js\n    function isFunction (value) {\n        if (!isObject(value)) {\n            return false;\n        }\n\n        const tag = getTag(value);\n        return (\n            tag === '[object Function]' ||\n        tag === '[object AsyncFunction]' ||\n        tag === '[object GeneratorFunction]' ||\n        tag === '[object Proxy]'\n        );\n    }\n\n    // https://github.com/lodash/lodash/blob/master/isString.js\n    function isString (value) {\n        const type = typeof value;\n        return (\n            type === 'string' ||\n        (type === 'object' &&\n          value != null &&\n          !Array.isArray(value) &&\n          getTag(value) === '[object String]')\n        );\n    }\n\n    function mapObject (value, fn) {\n        if (!isObject(value)) {\n            return [];\n        }\n        return Object.keys(value).map(key => fn(value[key], key));\n    }\n\n    function serialize (config, req, res) {\n        if (res.data) {\n        // FIXME: May be useless as localForage and axios already parse automatically\n            try {\n                res.data = JSON.parse(res.data);\n            } catch (err) {\n                config.debug('Could not parse data as JSON', err);\n            }\n        }\n\n        const { request, config: _, ...serialized } = res;\n        return serialized;\n    }\n\n    async function write (config, req, res) {\n        try {\n            const entry = {\n                expires: config.expires,\n                data: serialize(config, req, res)\n            };\n\n            await config.store.setItem(config.uuid, entry);\n        } catch (err) {\n            config.debug('Could not store response', err);\n\n            if (config.clearOnError) {\n                try {\n                    await config.store.clear();\n                } catch (err) {\n                    config.debug('Could not clear store', err);\n                }\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    async function read (config, req) {\n        const { uuid, ignoreCache } = config;\n\n        const entry = await config.store.getItem(uuid);\n\n        if (ignoreCache || !entry || !entry.data) {\n            config.debug('cache-miss', req.url);\n            const error = new Error();\n\n            error.reason = 'cache-miss';\n            error.message = 'Entry not found from cache';\n\n            throw error;\n        }\n\n        const { expires, data } = entry;\n\n        // Do not check for stale cache if offline on client-side\n        const offline = typeof navigator !== 'undefined' && 'onLine' in navigator && !navigator.onLine;\n\n        if (!offline && !config.acceptStale && expires !== 0 && (expires < Date.now())) {\n            config.debug('cache-stale', req.url);\n            const error = new Error();\n\n            error.reason = 'cache-stale';\n            error.message = 'Entry is stale';\n\n            throw error;\n        }\n\n        config.debug(config.acceptStale ? 'cache-hit-stale' : 'cache-hit', req.url);\n\n        return data;\n    }\n\n    function key (config) {\n        if (isFunction(config.key)) return config.key;\n\n        let cacheKey;\n        if (isString(config.key)) {\n            cacheKey = req => {\n                const url = `${req.baseURL ? req.baseURL : ''}${req.url}`;\n                const key = `${config.key}/${url}${serializeQuery(req)}`;\n                return req.data ? key + md5(req.data) : key;\n            };\n        } else {\n            cacheKey = req => {\n                const url = `${req.baseURL ? req.baseURL : ''}${req.url}`;\n                const key = url + serializeQuery(req);\n                return req.data ? key + md5(req.data) : key;\n            };\n        }\n\n        return cacheKey;\n    }\n\n    async function defaultInvalidate (config, req) {\n        const method = req.method.toLowerCase();\n        if (config.exclude.methods.includes(method)) {\n            await config.store.removeItem(config.uuid);\n        }\n    }\n\n    function invalidate (config = {}) {\n        if (isFunction(config.invalidate)) return config.invalidate;\n        return defaultInvalidate;\n    }\n\n    function serializeQuery (req) {\n        if (!req.params) return '';\n\n        // Probably server-side, just stringify the object\n        if (typeof URLSearchParams === 'undefined') return JSON.stringify(req.params);\n\n        let params = req.params;\n\n        const isInstanceOfURLSearchParams = req.params instanceof URLSearchParams;\n\n        // Convert to an instance of URLSearchParams so it get serialized the same way\n        if (!isInstanceOfURLSearchParams) {\n            params = new URLSearchParams();\n            Object.keys(req.params).forEach(key => params.append(key, req.params[key]));\n        }\n\n        return `?${params.toString()}`;\n    }\n\n    async function response (config, req, res) {\n        const { request = {}, headers = {} } = res;\n\n        // exclude binary response from cache\n        if (['arraybuffer', 'blob'].indexOf(request.responseType) > -1) {\n            return res;\n        }\n\n        let cacheControl$1 = {};\n\n        // Should we try to determine request cache expiration from headers or not\n        if (config.readHeaders) {\n            if (headers['cache-control']) { // Try parsing `cache-control` header from response\n                cacheControl$1 = cacheControl.parse(headers['cache-control']);\n\n                // Force cache exlcusion for `cache-control: no-cache` and `cache-control: no-store`\n                if (cacheControl$1.noCache || cacheControl$1.noStore) {\n                    config.excludeFromCache = true;\n                }\n            } else if (headers.expires) { // Else try reading `expires` header\n                config.expires = new Date(headers.expires).getTime();\n            } else {\n                config.expires = new Date().getTime();\n            }\n        }\n\n        if (!config.excludeFromCache) {\n            if (cacheControl$1.maxAge || cacheControl$1.maxAge === 0) {\n                // Use `cache-control` header `max-age` value and convert to milliseconds\n                config.expires = Date.now() + (cacheControl$1.maxAge * 1000);\n            } else if (!config.readHeaders) {\n                // Use fixed `maxAge` defined in the global or per-request config\n                config.expires = config.maxAge === 0 ? Date.now() : Date.now() + config.maxAge;\n            }\n\n            // Check if a cache limit has been configured\n            if (config.limit) {\n                config.debug(`Detected limit: ${config.limit}`);\n\n                await limit(config);\n            }\n\n            // Write response to cache\n            await write(config, req, res);\n        } else {\n        // Mark request as excluded from cache\n            res.request.excludedFromCache = true;\n        }\n\n        return res;\n    }\n\n    function exclude (config = {}, req) {\n        const { exclude = {}, debug } = config;\n        const method = req.method.toLowerCase();\n\n        if (method === 'head' || exclude.methods.includes(method)) {\n            debug(`Excluding request by HTTP method ${req.url}`);\n\n            return true;\n        }\n\n        if ((typeof exclude.filter === 'function') && exclude.filter(req)) {\n            debug(`Excluding request by filter ${req.url}`);\n\n            return true;\n        }\n\n        // do not cache request with query\n        const hasQueryParams = /\\?.*$/.test(req.url) ||\n        (isObject(req.params) && Object.keys(req.params).length !== 0) ||\n        (typeof URLSearchParams !== 'undefined' && req.params instanceof URLSearchParams);\n\n        if (exclude.query && hasQueryParams) {\n            debug(`Excluding request by query ${req.url}`);\n\n            return true;\n        }\n\n        const paths = exclude.paths || [];\n        const found = paths.some(regexp => req.url.match(regexp));\n\n        if (found) {\n            debug(`Excluding request by url match ${req.url}`);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    async function request (config, req) {\n        config.debug('uuid', config.uuid);\n\n        const next = (...args) => response(config, req, ...args);\n\n        // run invalidate function to check if any cache items need to be invalidated.\n        await config.invalidate(config, req);\n\n        if (exclude(config, req)) {\n            return excludeFromCache();\n        }\n\n        try {\n            const res = await read(config, req);\n\n            res.config = req;\n            res.request = { fromCache: true };\n\n            return { config, next: res };\n        } catch (err) {\n        // clean up cache if stale\n            if (config.clearOnStale && err.reason === 'cache-stale') {\n                await config.store.removeItem(config.uuid);\n            }\n\n            return { config, next };\n        }\n\n        // Helpers\n\n        function excludeFromCache () {\n            config.excludeFromCache = true;\n\n            return { config, next };\n        }\n    }\n\n    class MemoryStore {\n        constructor () {\n            this.store = {};\n        }\n\n        async getItem (key) {\n            const item = this.store[key] || null;\n\n            return JSON.parse(item);\n        }\n\n        async setItem (key, value) {\n            this.store[key] = JSON.stringify(value);\n\n            return value;\n        }\n\n        async removeItem (key) {\n            delete this.store[key];\n        }\n\n        async clear () {\n            this.store = {};\n        }\n\n        async length () {\n            return Object.keys(this.store).length;\n        }\n\n        iterate (fn) {\n            return Promise.all(mapObject(this.store, fn));\n        }\n    }\n\n    const noop = () => {};\n    const debug = (...args) => console.log('[axios-cache-adapter]', ...args);\n\n    const defaults = {\n        // Default settings when solely creating the cache adapter with setupCache.\n        cache: {\n            maxAge: 0,\n            limit: false,\n            store: null,\n            key: null,\n            invalidate: null,\n            exclude: {\n                paths: [],\n                query: true,\n                filter: null,\n                methods: ['post', 'patch', 'put', 'delete']\n            },\n            clearOnStale: true,\n            clearOnError: true,\n            readOnError: false,\n            readHeaders: false,\n            debug: false,\n            ignoreCache: false,\n            adapter: async (config, requestData) => {\n                const { method, url, ...rest } = requestData;\n                const { baseURL } = config;\n\n                const api = Axios.create({...rest, baseURL, adapter: Axios.defaults.adapter});\n\n                return api[method](url);\n            }\n        },\n\n        // Additional defaults when creating the axios instance with the cache adapter.\n        axios: {\n            cache: {\n                maxAge: 15 * 60 * 1000\n            }\n        }\n    };\n\n    // List of disallowed in the per-request config.\n    const disallowedPerRequestKeys = ['limit', 'store', 'adapter', 'uuid', 'acceptStale'];\n\n    /**\n     * Make a global config object.\n     *\n     * @param {Object} [override={}] Optional config override.\n     * @return {Object}\n     */\n    const makeConfig = function (override = {}) {\n        const config = {\n            ...defaults.cache,\n            ...override,\n            exclude: {\n                ...defaults.cache.exclude,\n                ...override.exclude\n            }\n        };\n\n        // Create a cache key method\n        config.key = key(config);\n        config.invalidate = invalidate(config);\n        // If debug mode is on, create a simple logger method\n        if (config.debug !== false) {\n            config.debug = typeof config.debug === 'function' ? config.debug : debug;\n        } else {\n            config.debug = noop;\n        }\n\n        // Create an in memory store if none was given\n        if (!config.store) config.store = new MemoryStore();\n\n        config.debug('Global cache config', config);\n\n        return config;\n    };\n\n    /**\n     * Merge the per-request config in another config.\n     *\n     * This method exists because not all keys should be allowed as it\n     * may lead to unexpected behaviours. For instance, setting another\n     * store or adapter per request is wrong, instead another instance\n     * axios, or the adapter, should be used.\n     *\n     * @param {Object} config Config object.\n     * @param {Object} req    The current axios request\n     * @return {Object}\n     */\n    const mergeRequestConfig = function (config, req) {\n        const requestConfig = req.cache || {};\n        if (requestConfig) {\n            disallowedPerRequestKeys.forEach(key => requestConfig[key] ? (delete requestConfig[key]) : undefined);\n        }\n\n        const mergedConfig = {\n            ...config,\n            ...requestConfig,\n            exclude: {\n                ...config.exclude,\n                ...requestConfig.exclude\n            }\n        };\n\n        if (mergedConfig.debug === true) {\n            mergedConfig.debug = debug;\n        }\n\n        // Create a cache key method\n        if (requestConfig.key) {\n            mergedConfig.key = key(requestConfig);\n        }\n\n        // Generate request UUID\n        mergedConfig.uuid = mergedConfig.key(req);\n\n        config.debug(`Request config for ${req.url}`, mergedConfig);\n\n        return mergedConfig;\n    };\n\n    /**\n     * Configure cache adapter\n     *\n     * @param   {object} [config={}] Cache adapter options\n     * @returns {object} Object containing cache `adapter` and `store`\n     */\n    function setupCache (config = {}) {\n        // Extend default configuration\n        config = makeConfig(config);\n\n        // Axios adapter. Receives the axios request configuration as only parameter\n        async function adapter (req) {\n            // Merge the per-request config with the instance config.\n            const reqConfig = mergeRequestConfig(config, req);\n\n            // Execute request against local cache\n            let res = await request(reqConfig, req);\n            const next = res.next;\n\n            // Response is not function, something was in cache, return it\n            if (!isFunction(next)) return {\n                ...next,\n                cached: true\n            };\n\n            // Nothing in cache so we execute the default adapter or any given adapter\n            // Will throw if the request has a status different than 2xx\n            let networkError;\n\n            try {\n                res = await reqConfig.adapter(reqConfig, req);\n                res.cached = false;\n            } catch (err) {\n                networkError = err;\n            }\n\n            if (networkError) {\n                // Check if we should attempt reading stale cache data\n                const readOnError = isFunction(reqConfig.readOnError)\n                    ? reqConfig.readOnError(networkError, req)\n                    : reqConfig.readOnError;\n\n                if (readOnError) {\n                    try {\n                        // Force cache tu return stale data\n                        reqConfig.acceptStale = true;\n\n                        // Try to read from cache again\n                        res = await request(reqConfig, req);\n\n                        // Signal that data is from stale cache\n                        res.next.request.stale = true;\n\n                        // No need to check if `next` is a function just return cache data\n                        return res.next;\n                    } catch (cacheReadError) {\n                        // Failed to read stale cache, do nothing here, just let the network error be thrown\n                    }\n                }\n\n                // Re-throw error so that it can be caught in userland if we didn't find any stale cache to read\n                throw networkError;\n            }\n\n            // Process response to store in cache\n            return next(res);\n        }\n\n        // Return adapter and store instance\n        return {\n            adapter,\n            config,\n            store: config.store\n        };\n    }\n\n    // ---------------------\n    // Easy API Setup\n    // ---------------------\n\n    /**\n     * Setup an axios instance with the cache adapter pre-configured\n     *\n     * @param {object} [options={}] Axios and cache adapter options\n     * @returns {object} Instance of Axios\n     */\n    function setup (config = {}) {\n        const instanceConfig = {\n            ...defaults.axios,\n            ...config,\n            cache: {\n                ...defaults.axios.cache,\n                ...config.cache\n            }\n        };\n\n        const cache = setupCache(instanceConfig.cache);\n        const { cache: _, ...axiosConfig } = instanceConfig;\n\n        const api = Axios.create(\n            { ...axiosConfig, adapter: cache.adapter }\n        );\n\n        api.cache = cache.store;\n\n        return api;\n    }\n\n    exports.serializeQuery = serializeQuery;\n    exports.setup = setup;\n    exports.setupCache = setupCache;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"file":"index.js"}